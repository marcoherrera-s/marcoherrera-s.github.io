<!doctype html> <html lang=en > <script> (function() { const theme = localStorage.getItem('theme'); if (theme === 'dark') { document.documentElement.classList.add('dark-theme'); } })(); </script> <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <meta name=google-site-verification  content=21AT8iolyuvHcdcAj2bmdauq6mqEd4a1fF4q-bsSUQY  /> <title>Ulam y mi cumplea√±os</title> <link href="https://fonts.googleapis.com/css2?family=Fira+Code&display=swap" rel=stylesheet > <link href="https://fonts.googleapis.com/css2?family=Merriweather:wght@700&display=swap" rel=stylesheet > <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/latex.css"> <link rel=stylesheet  href="/css/style.css"> <link rel=stylesheet  href="/css/carrusel.css"> <link rel=stylesheet  href="/css/libros.css"> <link id=dark-mode-style  rel=stylesheet  href="/css/dark-mode.css"> <link id=highlight-style-light  rel=stylesheet  href="/libs/highlight/styles/default.min.css"> <link id=highlight-style-dark  rel=stylesheet  href="/libs/highlight/styles/felipec.min.css" disabled> <script src="/dark-mode.js" defer></script> <script src="/script.js" defer></script> <div class=toggle-switch > <label class=switch-label > <input type=checkbox  class=checkbox  id=dark-mode-toggle > <span class=slider ></span> </label> </div> <div id=layout > <button id=hamburger-button  aria-label="Abrir men√∫" aria-expanded=false  aria-controls=menu > <svg width=18  height=18  viewBox="0 0 24 24" fill=none  stroke=currentColor  stroke-width=2  stroke-linecap=round ><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="18" x2="21" y2="18"/></svg> </button> <div id=menu > <ul> <li><a href="/"> ìáºinicioìáº </a> <li><a href="/menu1">f√≠sica ìá¢ìÜ∏</a> <li><a href="/menu2/">miscel√°nea ìÜù</a> <li><a href="/menu3/">subrayados ìÖ∏</a> </ul> </div> <div id=main > <div class=franklin-content ><h1 id="sobre_mi_n√∫mero_favorito_los_n√∫meros_primos_y_mi_fondo_de_pantalla"><a href="#sobre_mi_n√∫mero_favorito_los_n√∫meros_primos_y_mi_fondo_de_pantalla" class=header-anchor >SOBRE MI N√öMERO FAVORITO, LOS N√öMEROS PRIMOS Y MI FONDO DE PANTALLA</a></h1> <p>Es bien sabido que de los n√∫meros primos se pueden obtener muchas cosas interesantes, son n√∫meros muy especiales, pues no tienen divisores, bueno, s√≥lo el 1 y √©l mismo.</p> <p>Lo que har√© aqu√≠, como todo lo que hago tamb√≠en por aqu√≠, no es nada nuevo, <em>no hay nada nuevo bajo el sol</em>.</p> <p>Resulta que un d√≠a, en un rato libre, me puse a hacer un c√≥digo que replicara la famosa <a href="https://en.wikipedia.org/wiki/Ulam_spiral">espiral de Ulam</a>. Que como su nombre nos dice, es una espiral en donde se distribuyen los n√∫meros primos. </p> <p>Lo primero que hab√≠a que hacer era justamente una funci√≥n que nos dijera si un n√∫mero, cual sea, es primo o no. Entonces, hacemos:</p> <pre><code class="julia hljs"><span class=hljs-keyword >function</span> es_primo(n)
    <span class=hljs-keyword >if</span> n &lt;= <span class=hljs-number >1</span>
        <span class=hljs-keyword >return</span> <span class=hljs-literal >false</span>
    <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >2</span>:isqrt(n)
        <span class=hljs-keyword >if</span> n % i == <span class=hljs-number >0</span>
            <span class=hljs-keyword >return</span> <span class=hljs-literal >false</span>
        <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >return</span> <span class=hljs-literal >true</span>
<span class=hljs-keyword >end</span></code></pre> <pre><code class="plaintext hljs">es_primo (generic function with 1 method)</code></pre>
<p>La forma en la que funciona es la siguiente:</p>
<ol>
<li><p><code>if n &lt;&#61; 1</code>: Aqu√≠ checamos si el n√∫mero <code>n</code> es menor o igual a 1. Si es as√≠, la funci√≥n nos regresa un falso porque sabemos que los n√∫meros primos son mayores que 1. &#40;No, no vamos a tomar al 1 como primo&#41;</p>

<li><p><code>for i in 2:isqrt&#40;n&#41;</code>: Aqui con un <code>for</code> iteramos sobre todos los n√∫meros desde 2 hasta la ra√≠z cuadrada entera de <code>n</code>. Esto lo hacemos para optimizar el rendimiento, ya que si hay un divisor de <code>n</code> mayor que su ra√≠z cuadrada, entonces tambi√©n habr√° otro menor que su ra√≠z cuadrada.</p>

<li><p><code>if n &#37; i &#61;&#61; 0</code>: Aqu√≠ en cada iteraci√≥n del bucle, verificamos si <code>n</code> es divisible por <code>i</code> sin dejar residuo &#40;es decir, <code>n</code> es divisible por <code>i</code>&#41;. Si es as√≠, significa que <code>n</code> tiene un divisor que no es 1 ni <code>n</code> mismo, lo cual contradice la definici√≥n de un n√∫mero primo. En este caso, la funci√≥n nos regresa <code>false</code>.</p>

<li><p>Despu√©s de salir del bucle <code>for</code>, la funci√≥n nos regresa <code>true</code>, indicando que el n√∫mero <code>n</code> no tiene divisores distintos de 1 y <code>n</code>, y por lo tanto, es primo.</p>

</ol>
<h2 id="haciendo_una_espiral_de_n√∫meros"><a href="#haciendo_una_espiral_de_n√∫meros" class=header-anchor >Haciendo una espiral de n√∫meros</a></h2>
<p>El siguiente paso es hacer una espiral de n√∫meros, este paso tiene su truquito y podr√≠a resultar medio complicado, conseguir acomodar los n√∫meros en cualquier matriz de nxn en forma de espiral puede resultar un poco laborioso.</p>
<p><img src="/assets/espiral.png" alt=espiral  /></p>
<p>Entonces, lo que haremos ser√°:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> spiral_matrix(n::<span class=hljs-built_in >Int</span>)
    dirs = [(<span class=hljs-number >0</span>, <span class=hljs-number >1</span>), (-<span class=hljs-number >1</span>, <span class=hljs-number >0</span>), (<span class=hljs-number >0</span>, -<span class=hljs-number >1</span>), (<span class=hljs-number >1</span>, <span class=hljs-number >0</span>)]
    cur = maxsteps = <span class=hljs-number >1</span>
    steps = num = <span class=hljs-number >0</span>
    pos = [n √∑ <span class=hljs-number >2</span> + <span class=hljs-number >1</span>, isodd(n) ? n √∑ <span class=hljs-number >2</span> + <span class=hljs-number >1</span> : n √∑ <span class=hljs-number >2</span>]
    M = <span class=hljs-built_in >Matrix</span>{<span class=hljs-built_in >Int</span>}(<span class=hljs-literal >undef</span>, n, n)

    <span class=hljs-keyword >while</span> num &lt; n^<span class=hljs-number >2</span>
        num += <span class=hljs-number >1</span>
        M[pos[<span class=hljs-number >1</span>], pos[<span class=hljs-number >2</span>]] = num
        steps += <span class=hljs-number >1</span>

        pos .+= dirs[cur]

        <span class=hljs-keyword >if</span> steps == maxsteps
            steps = <span class=hljs-number >0</span>
            <span class=hljs-keyword >if</span> iseven(cur)
                maxsteps += <span class=hljs-number >1</span>
            <span class=hljs-keyword >end</span>
            cur += <span class=hljs-number >1</span>
            <span class=hljs-keyword >if</span> cur &gt; <span class=hljs-number >4</span>
                cur -= <span class=hljs-number >4</span>
            <span class=hljs-keyword >end</span>
        <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >end</span>

    <span class=hljs-keyword >return</span> M
<span class=hljs-keyword >end</span></code></pre>
<pre><code class="plaintext hljs">spiral_matrix (generic function with 1 method)</code></pre>
<p>Aqu√≠ basicamente lo que hacemos es crear una matriz cuadrada de tama√±o <code>n</code>, comenzamos localizando el centro y empezando ah√≠, ya sea si la matriz de nxn es con n par o n impar, ya en el centro de la matriz, avanzamos hacia afuera en direcciones predefinidas. Estas direcciones las manejamos mediante la variable <code>cur</code>, que representa la direcci√≥n actual, y el vector de direcciones <code>dirs</code>, que contiene las tuplas de desplazamiento correspondientes a cada direcci√≥n: hacia la derecha &#40;0, 1&#41;, hacia arriba &#40;-1, 0&#41;, hacia la izquierda &#40;0, -1&#41; y hacia abajo &#40;1, 0&#41;. Finalmente utilizamos un bucle <code>while</code> que contin√∫a hasta que todos los elementos de la matriz est√°n llenos. En cada iteraci√≥n del bucle:</p>
<p>Podemos ver nuestro resultado haciendo:</p>
<pre><code class="julia hljs">spiral_matrix(<span class=hljs-number >7</span>)</code></pre>
<pre><code class="plaintext hljs">7√ó7 Matrix{Int64}:
 37  36  35  34  33  32  31
 38  17  16  15  14  13  30
 39  18   5   4   3  12  29
 40  19   6   1   2  11  28
 41  20   7   8   9  10  27
 42  21  22  23  24  25  26
 43  44  45  46  47  48  49</code></pre>
<p>Genial, funciona. Ahora ya toca la parte f√°cil, para continuar tenemos que importar una paqueter√≠a para hacer nuestras im√°genes.</p>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> Images</code></pre>
<p>Entonces, lo siguiente que haremos ser√° lo siguiente:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> Ulam(n)
    M = spiral_matrix(n)
    primos = fill(RGB(<span class=hljs-number >0.0</span>, <span class=hljs-number >0.0</span>, <span class=hljs-number >0.0</span>), n, n)

    <span class=hljs-keyword >for</span> p <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:n, q <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:n
        <span class=hljs-keyword >if</span> es_primo(M[p, q]) 
            primos[p,q] = RGB(<span class=hljs-number >1.0</span>, <span class=hljs-number >0.0</span>, <span class=hljs-number >0.0</span>)
        <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >end</span>
    primos
<span class=hljs-keyword >end</span></code></pre>
<pre><code class="plaintext hljs">Ulam (generic function with 1 method)</code></pre>
<p>Lo que hicimos fue una funci√≥n que nos regresar√° una imagen de nuestra espiral de Ulam, primero creamos una matriz de nxn, y despu√©s con la paqueter√≠a creamos otra matriz de las mismas dimensiones con objetos RGB, cada elemento ser√° un pixel negro.  Despu√©s iteramos sobre cada columna y cada fila, es decir, sobre cada n√∫mero y con nuestra primera funci√≥n checamos si es primo, si lo es, sustituimos nuestro pixel negro, por uno rojo. Y as√≠ para todos los elementos de nuestra matriz. Veamos:</p>
<pre><code class="julia hljs">Ulam(<span class=hljs-number >1001</span>)</code></pre>
<p><img src="/assets/primos1001.png" alt=espabu  /></p>
<p>Perfecto, se ve muy bien. Ah√≠ tenemos nuestra espiral de Ulam.</p>
<p>Cuando llegu√© hasta ah√≠ ten√≠a ganas de hacer algo m√°s con todo esto, muy bonito y todo, pero ten√≠a sed de algo m√°s, entonces se me ocurri√≥ algo sencillo. Mi n√∫mero favorito es el 7, s√≠, entiendo que es un n√∫mero favorito <em>clich√©</em>, pero me gusta, es el d√≠a de mi cumplea√±os, <em>en el s√©ptimo d√≠a descans√≥</em>, hay 7 colores en el espectro visible, hay 7 notas musicales. Entre muchas cosas m√°s, simplemente el 7 es el mejor n√∫mero y no pienso discutirlo. </p>
<p>Entonces lo que hice fue lo siguiente:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> tiene_siete(numero)
    cadena_numero = string(numero)
    <span class=hljs-keyword >return</span> <span class=hljs-string >&#x27;7&#x27;</span> <span class=hljs-keyword >in</span> cadena_numero
<span class=hljs-keyword >end</span></code></pre>
<pre><code class="plaintext hljs">tiene_siete (generic function with 1 method)</code></pre>
<p>Esta es una funci√≥n simple que lo que hace es checar si un n√∫mero cualquiera, contiene al 7 entre sus d√≠gitos. Entonces, modifiquemos nuestra funci√≥n <em>Ulam&#40;&#41;</em> a√±adiendo esa funci√≥n. </p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> Ulam_n(n)
    M = spiral_matrix(n)
    primos = fill(RGB(<span class=hljs-number >0.0</span>, <span class=hljs-number >0.0</span>, <span class=hljs-number >0.0</span>), n, n)

    <span class=hljs-keyword >for</span> p <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:n, q <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:n
        <span class=hljs-keyword >if</span> es_primo(M[p, q]) &amp;&amp; tiene_siete(M[p, q])
            primos[p,q] = RGB(<span class=hljs-number >1.0</span>, <span class=hljs-number >0.0</span>, <span class=hljs-number >0.0</span>)
        <span class=hljs-keyword >elseif</span> es_primo(M[p, q]) 
            primos[p,q] = RGB(<span class=hljs-number >1.0</span>, <span class=hljs-number >1.0</span>, <span class=hljs-number >1.0</span>)

        <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >end</span>
    primos
<span class=hljs-keyword >end</span></code></pre>
<pre><code class="plaintext hljs">Ulam_n (generic function with 1 method)</code></pre>
<p>Es la misma funci√≥n, √∫nicamente agregamos la condici√≥n de que si es primo y adem√°s tiene el 7, se pinte de rojo, si solamente es un n√∫mero primo sin tener el 7, es decir, un n√∫mero primo aburrido, que se pinte de blanco. Volvamos a hacer una imagen de eso. </p>
<pre><code class="julia hljs">Ulam_n(<span class=hljs-number >1001</span>)</code></pre>
<p><img src="/assets/primoss1001.png" alt=espachi  /></p>
<p>Bueno, esto sorprendente para m√≠ la primera vez que lo vi, la verdad es que no esperaba para nada esto, lo que yo esperaba era una distribuci√≥n random de puntos rojos y puntos blancos, pero no, s√≠, est√°s viendo bien, se forman especies de m√°rgenes, de cuadrados. </p>
<p>La parte triste de todo esto es que, como era de esperarse, esos patrones no son una particularidad del 7, sino de todos los n√∫meros, del 1-9 con los que prob√©. </p>
<p>Resulta que a d√≠a de hoy a√∫n no puedo explicar muy bien lo que est√° pasando, por qu√© estoy viendo lo que estoy viendo, alg√∫n d√≠a cuando le pregunte a alg√∫n matem√°tico, pondr√© la respuesta aqu√≠, tengo una idea vaga, pero nada que me atreva a escribir con seguridad. </p>
<p>Una vez, una amiga m√≠a me pregunt√≥ que cu√°l era mi fondo de pantalla, a punto de ense√±arle me dijo que me detuviera, que ella iba a adivinar, empez√≥ diciendo una lista de las cosas que me gustan tales que cre√≠a que eso podr√≠a ser mi fondo de pantalla, fue un fallo total. Mi fondo de pantalla era un fondo random, algo que literalmente no hubiera recordado cu√°ndo puse, ni por qu√©, ni d√≥nde lo encontr√©, algo similar a ese fondo de pantalla del campo verde y el cielo azul que estuvo como predeterminado mucho tiempo en las computadoras.</p>
<p><img src="/assets/fondo.jpg" alt=fon  /></p>
<p>En el momento en que obtuve mi imagen, de los n√∫meros primos y mi n√∫mero favorito, no dud√© en ponerla de fondo de pantalla. </p>
<p>Tiempo despu√©s, al volver a encontrar a mi amiga, me pregunt√≥, casi en tono de burla, que cu√°l era mi fondo de pantalla ahora. Y bueno, no pude explicar todo lo que est√° en esta entrada de blog. </p>
<!-- <div class=page-foot  style="font-size: 8px; font-family: 'Sans-serif', Arial, sans-serif; text-align: center; color: #666;">
    <span>&copy; {{ fill author }}.</span> 
    {{isnotpage /tag/*}}<span>√öltima modificaci√≥n: {{ fill fd_mtime }}.</span>{{end}}
    <br>
    Sitio creado con 
    <a href="https://github.com/tlienart/Franklin.jl" target=_blank  style="color: #90be6d; text-decoration: none;">Franklin.jl</a> 
    y 
    <a href="https://julialang.org" target=_blank  style="color: #90be6d; text-decoration: none;">Julia programming language</a>.
</div> -->
</div>
        </div> 
    </div> 
    
    
        <script src="/libs/highlight/highlight.min.js"></script>
<script>hljs.highlightAll();hljs.configure({tabReplace: '    '});</script>